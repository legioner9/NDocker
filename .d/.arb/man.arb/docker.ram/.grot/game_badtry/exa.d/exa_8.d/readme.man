# volumes

Ранее мы рассматривали, как примонтировать папку в контейнер, для этого мы запускали контейнер с аргументом -v <HOST_DIRECTORY>:<CONTAINER_DIRECTORY>.
С Docker-compose мы можем указать напрямую в docker-compose.yml:

version: '3'
services:
  app:
    build:
      context: .
    ports:
      - 8081:80
    volumes:
      - .:/var/www/html

Добавленная строка примонтирует текущую директорию основой операционной системы к директории /var/www/html контейнера.

В отличие от указания путь в консоли, здесь можно указывать относительный путь (.), не обязательно указывать полный путь (C:\projects\docker-example\apache), как было ранее при ручном запуске контейнера.

Теперь, выполните по очереди команды:

docker-compose stop
docker-compose rm

При удалении, вас спросят, действительно ли удалять, напишите y и нажмите кнопку enter. Эти команды остановят и удалят все контейнеры, описанные в файле docker-compose.yml (то же самое, как мы ранее запускали docker stop <CONTAINER_ID> и docker rm <CONTAINER_ID>)

Теперь перебилдим сервисы, потому что мы изменили Dockerfile:

docker-compose build

И заново запустим:

docker-compose up

И опять, по адресу localhost:8080 поднимется наш сервер.

Вместо того, чтобы копировать каждый раз файлы в образ, мы просто примонтировали папку, содержащую исходный код приложения. И теперь, каждый раз не придётся делать ребилд образа, когда файлы изменяются, теперь изменения происходят в лайв режиме, и будут доступны без перестройки образа.

Чтобы в этом убедиться, изменим файл index.php, добавим в него скрипт нами любимой пирамиды:

<?php
$n = $i = $_GET['count'] ?? 4;
echo '<pre>';
while ($i--) {
    echo str_repeat(' ', $i).str_repeat('* ', $n - $i)."\n";
}
echo '</pre>';

И теперь, если перейти по адресу localhost:8080?count=10, то увидим, что пирамида выводится:apache_index_count

Монтирование вашей локальной папки как Docker Volume это основной метод как разрабатывать приложения в контейнере.